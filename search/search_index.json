{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"badfiles \u00b6 A malicious file detection engine written with Python and Yara. Free software: Apache-2.0 Documentation: https://jeffallan.github.io/badfiles/ Introduction \u00b6 At some point most applications need to accept files from a third party. Since we do not have absolute control over these files they can present a serious threat vector. The aim of this project is to provide a flexible and expandable solution to triage these files so they can be handled accordingly. Features \u00b6 Currently, this project focuses on detecting the following: Generally Suspicious Files: \u00b6 Mime type confusion. Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only). CSV Files \u00b6 CSV Injection. Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only). Office Documents \u00b6 DDE injection. Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only). Zip Files \u00b6 Symlink attacks. Zip slips. Nested zip bombs. Flat zip bombs. Sticky, setuid, or setgit bit (*NIX only). Files with a root UID or GID (*NIX only). Tar Files \u00b6 Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only). Files with absolute paths (*Nix only). Additional Features \u00b6 Please file an issue or a pull request especially if you have found or created malicious files that bypass these detection mechanisms. Please see the contributing guidelines for more details. Getting Started \u00b6 Usage \u00b6 Credits \u00b6 This package was created with This Cookiecutter template. This project uses zip-bomb to create the nested and flat zip bombs for unit testing and detection rules. This project uses a custom Yara rule from Reversing Labs to detect obfuscated CSV injection payloads. Contributors \u00b6","title":"home"},{"location":"#badfiles","text":"A malicious file detection engine written with Python and Yara. Free software: Apache-2.0 Documentation: https://jeffallan.github.io/badfiles/","title":"badfiles"},{"location":"#introduction","text":"At some point most applications need to accept files from a third party. Since we do not have absolute control over these files they can present a serious threat vector. The aim of this project is to provide a flexible and expandable solution to triage these files so they can be handled accordingly.","title":"Introduction"},{"location":"#features","text":"Currently, this project focuses on detecting the following:","title":"Features"},{"location":"#generally-suspicious-files","text":"Mime type confusion. Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only).","title":"Generally Suspicious Files:"},{"location":"#csv-files","text":"CSV Injection. Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only).","title":"CSV Files"},{"location":"#office-documents","text":"DDE injection. Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only).","title":"Office Documents"},{"location":"#zip-files","text":"Symlink attacks. Zip slips. Nested zip bombs. Flat zip bombs. Sticky, setuid, or setgit bit (*NIX only). Files with a root UID or GID (*NIX only).","title":"Zip Files"},{"location":"#tar-files","text":"Files with a root UID or GID (*NIX only). Sticky, setuid, or setgit bit (*NIX only). Files with absolute paths (*Nix only).","title":"Tar Files"},{"location":"#additional-features","text":"Please file an issue or a pull request especially if you have found or created malicious files that bypass these detection mechanisms. Please see the contributing guidelines for more details.","title":"Additional Features"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#usage","text":"","title":"Usage"},{"location":"#credits","text":"This package was created with This Cookiecutter template. This project uses zip-bomb to create the nested and flat zip bombs for unit testing and detection rules. This project uses a custom Yara rule from Reversing Labs to detect obfuscated CSV injection payloads.","title":"Credits"},{"location":"#contributors","text":"","title":"Contributors"},{"location":"api/","text":"Badfile dataclass \u00b6 The class that implements the badfiles detection engine. Attributes: Name Type Description zip_rules Optional[str] The path to yara detection rules for zip files (defaults to ./rules/zip_rules.yara) tar_rules Optional[str] The path to yara detection rules for tar files (defaults to ./rules/tar_rules.yara) csv_rules Optional[str] The path to yara detection rules for tar files (defaults to ./rules/csv_rules.yara) is_badfile ( self , f ) \u00b6 This function checks for various indicators of potentially malicious content including: - Mime Type confusion; - Zip files with high compression rates and; - Hands f to the proper yara detection rules. Parameters: Name Type Description Default f PathLike The path of the file to be analyzed required Returns: Type Description BadfileMsg The BadfileMsg named tuple Source code in badfiles/badfiles.py def is_badfile ( self , f : PathLike ) -> BadfileMsg : \"\"\"This function checks for various indicators of potentially malicious content including: - Mime Type confusion; - Zip files with high compression rates and; - Hands f to the proper yara detection rules. Args: f (PathLike): The path of the file to be analyzed Returns: BadfileMsg: The BadfileMsg named tuple \"\"\" is_mime_confusion = self . _mime_type_confusion ( f ) if is_mime_confusion [ 0 ] is False : return BadfileMsg ( Classification . UNSAFE . value , f \"Deceptive extension. File extension suggests { is_mime_confusion [ 2 ] } inspection shows { is_mime_confusion [ 1 ] } \" , pathlib . Path ( f ) . name , ) if is_mime_confusion [ 1 ] == \"application/zip\" : if self . _high_compression ( f ): return BadfileMsg ( Classification . UNSAFE . value , \"high compression rate\" , pathlib . Path ( f ) . name ) return self . _rule_factory ( f , is_mime_confusion [ 1 ]) BadfileMsg ( tuple ) \u00b6 BadfileMsg(classification, message, file) __getnewargs__ ( self ) special \u00b6 Return self as a plain tuple. Used by copy and pickle. Source code in badfiles/badfiles.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self ) __new__ ( _cls , classification , message , file ) special staticmethod \u00b6 Create new instance of BadfileMsg(classification, message, file) __repr__ ( self ) special \u00b6 Return a nicely formatted representation string Source code in badfiles/badfiles.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self Classification ( Enum ) \u00b6 The results returned by the BadFile class Attributes: Name Type Description SAFE str Nothing malicious was detected. UNSAFE str Malicious content was detected. NOT_IMPLEMENTED str The file type has not been implemented in the detection engine. UNKNOWN str The file type cannot be determined. find_dde ( doc_dir ) \u00b6 Iterates through doc_dir and searches for a directory called externalLinks. Parameters: Name Type Description Default doc_dir PathLike The target directory to be analyzed. required Returns: Type Description bool True if a folder called externalLinks otherwise returns False. Source code in badfiles/utils.py def find_dde ( doc_dir : Path ) -> bool : \"\"\"Iterates through doc_dir and searches for a directory called externalLinks. Args: doc_dir (PathLike): The target directory to be analyzed. Returns: bool: True if a folder called externalLinks otherwise returns False. \"\"\" p = Path ( doc_dir ) dde = False for i in p . glob ( \"**/*\" ): if i . name . lower () == \"externallinks\" : dde = True shutil . rmtree ( doc_dir ) return dde process_tar ( f , chunk = 512 ) \u00b6 A generator function that yields tar file headers. Parameters: Name Type Description Default f PathLike The path the the tar file. required chunk int The size of the tarfile chunks. Defaults to 512. 512 Yields Generator[bytes, None, None]: Tar file header(s). Source code in badfiles/utils.py def process_tar ( f : str , chunk : int = 512 ) -> Generator [ bytes , None , None ]: \"\"\"A generator function that yields tar file headers. Args: f (PathLike): The path the the tar file. chunk (int, optional): The size of the tarfile chunks. Defaults to 512. Yields: Generator[bytes, None, None]: Tar file header(s). \"\"\" with open ( f , \"rb\" ) as f : for fh in iter ( partial ( f . read , chunk ), b \"\" ): try : data = fh # size = data.decode(\"ascii\")[124:135] # print(size) if data . decode ( \"ascii\" )[ 257 : 262 ] == \"ustar\" and data [ 125 : 135 ] . isascii (): yield data except ( UnicodeDecodeError , ValueError ): pass unzip_doc ( doc , dir = PosixPath ( '/home/runner/work/badfiles/badfiles/tmp_doc' )) \u00b6 Unzips a document to enable the find_dde function. Parameters: Name Type Description Default doc PathLike The path to the document to unzip required dir str The directory to unzip the document. Defaults to \"./tmp_doc\". PosixPath('/home/runner/work/badfiles/badfiles/tmp_doc') Returns: Type Description PathLike The directory of the unzipped document. Source code in badfiles/utils.py def unzip_doc ( doc : PathLike , dir = pathlib . Path ( RULE_DIR ) . parent / \"./tmp_doc\" ) -> PathLike : \"\"\"Unzips a document to enable the find_dde function. Args: doc (PathLike): The path to the document to unzip dir (str, optional): The directory to unzip the document. Defaults to \"./tmp_doc\". Returns: PathLike: The directory of the unzipped document. \"\"\" z = zipfile . ZipFile ( doc ) z . extractall ( path = dir ) return dir","title":"modules"},{"location":"api/#badfiles.badfiles.Badfile","text":"The class that implements the badfiles detection engine. Attributes: Name Type Description zip_rules Optional[str] The path to yara detection rules for zip files (defaults to ./rules/zip_rules.yara) tar_rules Optional[str] The path to yara detection rules for tar files (defaults to ./rules/tar_rules.yara) csv_rules Optional[str] The path to yara detection rules for tar files (defaults to ./rules/csv_rules.yara)","title":"Badfile"},{"location":"api/#badfiles.badfiles.Badfile.is_badfile","text":"This function checks for various indicators of potentially malicious content including: - Mime Type confusion; - Zip files with high compression rates and; - Hands f to the proper yara detection rules. Parameters: Name Type Description Default f PathLike The path of the file to be analyzed required Returns: Type Description BadfileMsg The BadfileMsg named tuple Source code in badfiles/badfiles.py def is_badfile ( self , f : PathLike ) -> BadfileMsg : \"\"\"This function checks for various indicators of potentially malicious content including: - Mime Type confusion; - Zip files with high compression rates and; - Hands f to the proper yara detection rules. Args: f (PathLike): The path of the file to be analyzed Returns: BadfileMsg: The BadfileMsg named tuple \"\"\" is_mime_confusion = self . _mime_type_confusion ( f ) if is_mime_confusion [ 0 ] is False : return BadfileMsg ( Classification . UNSAFE . value , f \"Deceptive extension. File extension suggests { is_mime_confusion [ 2 ] } inspection shows { is_mime_confusion [ 1 ] } \" , pathlib . Path ( f ) . name , ) if is_mime_confusion [ 1 ] == \"application/zip\" : if self . _high_compression ( f ): return BadfileMsg ( Classification . UNSAFE . value , \"high compression rate\" , pathlib . Path ( f ) . name ) return self . _rule_factory ( f , is_mime_confusion [ 1 ])","title":"is_badfile()"},{"location":"api/#badfiles.badfiles.BadfileMsg","text":"BadfileMsg(classification, message, file)","title":"BadfileMsg"},{"location":"api/#badfiles.badfiles.BadfileMsg.__getnewargs__","text":"Return self as a plain tuple. Used by copy and pickle. Source code in badfiles/badfiles.py def __getnewargs__ ( self ): 'Return self as a plain tuple. Used by copy and pickle.' return _tuple ( self )","title":"__getnewargs__()"},{"location":"api/#badfiles.badfiles.BadfileMsg.__new__","text":"Create new instance of BadfileMsg(classification, message, file)","title":"__new__()"},{"location":"api/#badfiles.badfiles.BadfileMsg.__repr__","text":"Return a nicely formatted representation string Source code in badfiles/badfiles.py def __repr__ ( self ): 'Return a nicely formatted representation string' return self . __class__ . __name__ + repr_fmt % self","title":"__repr__()"},{"location":"api/#badfiles.badfiles.Classification","text":"The results returned by the BadFile class Attributes: Name Type Description SAFE str Nothing malicious was detected. UNSAFE str Malicious content was detected. NOT_IMPLEMENTED str The file type has not been implemented in the detection engine. UNKNOWN str The file type cannot be determined.","title":"Classification"},{"location":"api/#badfiles.utils.find_dde","text":"Iterates through doc_dir and searches for a directory called externalLinks. Parameters: Name Type Description Default doc_dir PathLike The target directory to be analyzed. required Returns: Type Description bool True if a folder called externalLinks otherwise returns False. Source code in badfiles/utils.py def find_dde ( doc_dir : Path ) -> bool : \"\"\"Iterates through doc_dir and searches for a directory called externalLinks. Args: doc_dir (PathLike): The target directory to be analyzed. Returns: bool: True if a folder called externalLinks otherwise returns False. \"\"\" p = Path ( doc_dir ) dde = False for i in p . glob ( \"**/*\" ): if i . name . lower () == \"externallinks\" : dde = True shutil . rmtree ( doc_dir ) return dde","title":"find_dde()"},{"location":"api/#badfiles.utils.process_tar","text":"A generator function that yields tar file headers. Parameters: Name Type Description Default f PathLike The path the the tar file. required chunk int The size of the tarfile chunks. Defaults to 512. 512 Yields Generator[bytes, None, None]: Tar file header(s). Source code in badfiles/utils.py def process_tar ( f : str , chunk : int = 512 ) -> Generator [ bytes , None , None ]: \"\"\"A generator function that yields tar file headers. Args: f (PathLike): The path the the tar file. chunk (int, optional): The size of the tarfile chunks. Defaults to 512. Yields: Generator[bytes, None, None]: Tar file header(s). \"\"\" with open ( f , \"rb\" ) as f : for fh in iter ( partial ( f . read , chunk ), b \"\" ): try : data = fh # size = data.decode(\"ascii\")[124:135] # print(size) if data . decode ( \"ascii\" )[ 257 : 262 ] == \"ustar\" and data [ 125 : 135 ] . isascii (): yield data except ( UnicodeDecodeError , ValueError ): pass","title":"process_tar()"},{"location":"api/#badfiles.utils.unzip_doc","text":"Unzips a document to enable the find_dde function. Parameters: Name Type Description Default doc PathLike The path to the document to unzip required dir str The directory to unzip the document. Defaults to \"./tmp_doc\". PosixPath('/home/runner/work/badfiles/badfiles/tmp_doc') Returns: Type Description PathLike The directory of the unzipped document. Source code in badfiles/utils.py def unzip_doc ( doc : PathLike , dir = pathlib . Path ( RULE_DIR ) . parent / \"./tmp_doc\" ) -> PathLike : \"\"\"Unzips a document to enable the find_dde function. Args: doc (PathLike): The path to the document to unzip dir (str, optional): The directory to unzip the document. Defaults to \"./tmp_doc\". Returns: PathLike: The directory of the unzipped document. \"\"\" z = zipfile . ZipFile ( doc ) z . extractall ( path = dir ) return dir","title":"unzip_doc()"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/jeffallan/badfiles/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 badfiles could always use more documentation, whether as part of the official badfiles docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/jeffallan/badfiles/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome. Get Started! \u00b6 Ready to contribute? Here's how to set up badfiles for local development. Fork the badfiles repo on GitHub. Clone your fork locally 1 git clone git@github.com:your_name_here/badfiles.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 poetry install -E test -E doc -E dev Install Yara and Python magic Create a branch for local development: 1 git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 tox Commit your changes and push your branch to GitHub: 1 2 3 git add . git commit -m \"Your detailed description of your changes.\" git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/jeffallan/badfiles/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 1 pytest tests.test_badfiles To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 poetry patch # possible: major / minor / patch git push git push --tags Github will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/jeffallan/badfiles/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"badfiles could always use more documentation, whether as part of the official badfiles docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/jeffallan/badfiles/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome.","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up badfiles for local development. Fork the badfiles repo on GitHub. Clone your fork locally 1 git clone git@github.com:your_name_here/badfiles.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 poetry install -E test -E doc -E dev Install Yara and Python magic Create a branch for local development: 1 git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 tox Commit your changes and push your branch to GitHub: 1 2 3 git add . git commit -m \"Your detailed description of your changes.\" git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/jeffallan/badfiles/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 pytest tests.test_badfiles To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 poetry patch # possible: major / minor / patch git push git push --tags Github will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"detection_methods/","text":"Generally Suspicious Files \u00b6 Mime Type Confusion \u00b6 Also known as mime type mismatch. This occurs when a file extension suggests one file type when it is actually another. An example of an attack using this principal can be found here . Mime type confusion is detected by comparing the expected mime type derived from the file extension and the actual file type by inspecting the magic bytes of the file using the _mime_type_confusion function. Files With a Root UID or GID or Sticky, Setuid, or Setgid Bit (*NIX only) \u00b6 Generally speaking, files that belong to the root user or root group are something we do not want to receive from a user especially if this file is also executable. This is also true for files with a setuid or set gid bit because they can be used to escalade privilege. Lastly, files with a sticky bit are flagged because this bit restricts file deletion to just the owner of the file. Detection strategies for the above vary by file type. Mostly, this is accomplished with a custom Yara rule CSV Files \u00b6 CSV Injection \u00b6 CSV injection occurs when a user chooses to open a CSV file in a program like Excel. While this attack vector is mitigated by the default settings in excel-like programs, these default settings vary from program to program. Additionally, an unsuspecting user can alter these settings; creating an unsafe environment. Furthermore, CSV injection payloads can be obfuscated to evade conventional detection methods. This Yara rule is used for detecting these types of files Zip Files \u00b6 Symlink Attacks \u00b6 A symlink attack works by creating a symlink to a target file like /etc/passwd and masking it with an arbitrary filename like safe_upload.jpg if this file is unzipped, any user that has the correct permissions for the target file can access it through the symlink. Symlinks attacks are detected with a Yara rule that checks for a symlink bit in the central file header ( 0x504B0102 ) Zip Slip \u00b6 A zip slip occurs when a zip file contains a name with a directory traversal build in (../../malicious_file.zip) which can lead to content being uploaded to unintended locations. Zip slips are detected by navigating to the central file header in the zip archive ( 0x504B0102 ) and searching for ../ at the beginning of the file name. Zip Bombs \u00b6 Zip Bombs come in two varieties nested and flat. In each case when this malicious file is unzipped it creates an extremely large file potentially causing a denial of service due to a lack of disk space on the server. Nested Zip Bombs \u00b6 A nested zip bomb is a zip file that contains other zip files. This type of zip bomb is detected by navigating to every local file header ( 0x504B0304 ) and searching for the string .zip Flat Zip Bombs \u00b6 Flat zip bombs are zip archives that are constructed in such a way that their compression rates are much higher than a normal zip files whose compression rates range from about 60%-70% ( citation needed ). To detect flat zip bombs one must investigate the compression rate of the zip archive. This is implemented in the _high_compression method Office Documents \u00b6 Office Documents (docx, xlsx, etc) use the zip file specification as the underlying file structure. Therefore, all zip file rules are applied to office documents before any further processing. DDE Injection \u00b6 DDE (Dynamic Data Exchange) injection behaves almost identically to CSV injection. The detection strategy is, however, different. After the file passes the zip file detection rules, it is safe to unzip . When the file is unzipped we look for a folder called externalLinks . If that folder exists the file uses the DDE protocol should be considered unsafe. This detection measure is implemented in the find_dde method Tar Files \u00b6 Files With Absolute Paths \u00b6 If a tar file contains a file with an absolute path, it will overwrite the file at that location if user who untars the file has the correct permissions. There are numerous targets a threat actor would be interested in including: /etc/passwd .bashrc .bash_aliases This detection mechanism has yet to be implemented.","title":"detection methods"},{"location":"detection_methods/#generally-suspicious-files","text":"","title":"Generally Suspicious Files"},{"location":"detection_methods/#mime-type-confusion","text":"Also known as mime type mismatch. This occurs when a file extension suggests one file type when it is actually another. An example of an attack using this principal can be found here . Mime type confusion is detected by comparing the expected mime type derived from the file extension and the actual file type by inspecting the magic bytes of the file using the _mime_type_confusion function.","title":"Mime Type Confusion"},{"location":"detection_methods/#files-with-a-root-uid-or-gid-or-sticky-setuid-or-setgid-bit-nix-only","text":"Generally speaking, files that belong to the root user or root group are something we do not want to receive from a user especially if this file is also executable. This is also true for files with a setuid or set gid bit because they can be used to escalade privilege. Lastly, files with a sticky bit are flagged because this bit restricts file deletion to just the owner of the file. Detection strategies for the above vary by file type. Mostly, this is accomplished with a custom Yara rule","title":"Files With a Root UID or GID or Sticky, Setuid, or Setgid Bit (*NIX only)"},{"location":"detection_methods/#csv-files","text":"","title":"CSV Files"},{"location":"detection_methods/#csv-injection","text":"CSV injection occurs when a user chooses to open a CSV file in a program like Excel. While this attack vector is mitigated by the default settings in excel-like programs, these default settings vary from program to program. Additionally, an unsuspecting user can alter these settings; creating an unsafe environment. Furthermore, CSV injection payloads can be obfuscated to evade conventional detection methods. This Yara rule is used for detecting these types of files","title":"CSV Injection"},{"location":"detection_methods/#zip-files","text":"","title":"Zip Files"},{"location":"detection_methods/#symlink-attacks","text":"A symlink attack works by creating a symlink to a target file like /etc/passwd and masking it with an arbitrary filename like safe_upload.jpg if this file is unzipped, any user that has the correct permissions for the target file can access it through the symlink. Symlinks attacks are detected with a Yara rule that checks for a symlink bit in the central file header ( 0x504B0102 )","title":"Symlink Attacks"},{"location":"detection_methods/#zip-slip","text":"A zip slip occurs when a zip file contains a name with a directory traversal build in (../../malicious_file.zip) which can lead to content being uploaded to unintended locations. Zip slips are detected by navigating to the central file header in the zip archive ( 0x504B0102 ) and searching for ../ at the beginning of the file name.","title":"Zip Slip"},{"location":"detection_methods/#zip-bombs","text":"Zip Bombs come in two varieties nested and flat. In each case when this malicious file is unzipped it creates an extremely large file potentially causing a denial of service due to a lack of disk space on the server.","title":"Zip Bombs"},{"location":"detection_methods/#nested-zip-bombs","text":"A nested zip bomb is a zip file that contains other zip files. This type of zip bomb is detected by navigating to every local file header ( 0x504B0304 ) and searching for the string .zip","title":"Nested Zip Bombs"},{"location":"detection_methods/#flat-zip-bombs","text":"Flat zip bombs are zip archives that are constructed in such a way that their compression rates are much higher than a normal zip files whose compression rates range from about 60%-70% ( citation needed ). To detect flat zip bombs one must investigate the compression rate of the zip archive. This is implemented in the _high_compression method","title":"Flat Zip Bombs"},{"location":"detection_methods/#office-documents","text":"Office Documents (docx, xlsx, etc) use the zip file specification as the underlying file structure. Therefore, all zip file rules are applied to office documents before any further processing.","title":"Office Documents"},{"location":"detection_methods/#dde-injection","text":"DDE (Dynamic Data Exchange) injection behaves almost identically to CSV injection. The detection strategy is, however, different. After the file passes the zip file detection rules, it is safe to unzip . When the file is unzipped we look for a folder called externalLinks . If that folder exists the file uses the DDE protocol should be considered unsafe. This detection measure is implemented in the find_dde method","title":"DDE Injection"},{"location":"detection_methods/#tar-files","text":"","title":"Tar Files"},{"location":"detection_methods/#files-with-absolute-paths","text":"If a tar file contains a file with an absolute path, it will overwrite the file at that location if user who untars the file has the correct permissions. There are numerous targets a threat actor would be interested in including: /etc/passwd .bashrc .bash_aliases This detection mechanism has yet to be implemented.","title":"Files With Absolute Paths"},{"location":"history/","text":"History \u00b6 0.1.0 (09/30/21) \u00b6 First release on PyPI. 0.3.0 (11/22/21) \u00b6 Release now in Alpha and ready for user feedback.","title":"history"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-093021","text":"First release on PyPI.","title":"0.1.0 (09/30/21)"},{"location":"history/#030-112221","text":"Release now in Alpha and ready for user feedback.","title":"0.3.0 (11/22/21)"},{"location":"installation/","text":"Installation \u00b6 This package can be installed with pip install badfiles . The package also provides a convenance script called badfiles that provides a GUI for the the detection engine. The badfiles command has an an additional dependency, Gooey . If you wish to use the badfiles script please install the additional dependency via pip install badfiles[gui] . This project requires a Yara installation. Installation instructions can be found here . This project also relies on python-magic which may require additional installation steps depending on your operating system.","title":"installation"},{"location":"installation/#installation","text":"This package can be installed with pip install badfiles . The package also provides a convenance script called badfiles that provides a GUI for the the detection engine. The badfiles command has an an additional dependency, Gooey . If you wish to use the badfiles script please install the additional dependency via pip install badfiles[gui] . This project requires a Yara installation. Installation instructions can be found here . This project also relies on python-magic which may require additional installation steps depending on your operating system.","title":"Installation"},{"location":"usage/","text":"Quickstart \u00b6 The Badfile class provides one public method called is_badfile which analyzes a file according to the detection methods outlined here . There is also a convenance method called isolate_or_clear to handle the file in question. Their usage is demonstrated below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from badfiles.badfiles import Badfiles , isolate_or_clear b = Badfile () bad = b . is_badfile ( f = file ) \"\"\" returns a named tuple with a classification: (safe, unsafe, unknown, or not implemented) message: A message explaining the classification file: The name of the file being analyzed \"\"\" isolate_or_clear ( f = file , msg = bad , iso_dir = iso_dir , safe_dir = safe_dir , safe = [ \"safe\" ,]) \"\"\" The safe parameter is a list of badfile classifications, returned from is_badfile(), that are deemed safe (defaults to [\"safe\",]). If the classification in the msg parameter is in the safe list the file is moved to safe_dir otherwise it is moved to iso_dir. \"\"\" Custom Yara Rules \u00b6 One may provide custom Yara detection rules upon class instantiation like so: 1 2 3 4 5 from badfiles.badfiles import Badfiles , isolate_or_clear b = Badfile ( zip_rules = \"/path/to/rules\" , tar_rules = \"/path/to/rules\" , csv_rules = \"/path/to/rules\" ) bad = b . is_badfile ( f = file ) Project Integration \u00b6 The aim of this library is to use it in larger projects and especially web applications. Here are a few ideas for how you can integrate badfiles into your current projects. Fast API \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import pathlib from fastapi import FastAPI , File , UploadFile from fastapi.responses import JSONResponse from badfiles.badfiles import Badfile import pathlib app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Welcome to the badfiles demo\" } @app . post ( \"/\" ) async def post_file ( f : UploadFile = File ( ... )): upload = pathlib . Path ( __file__ ) . parent / \"uploads\" / f . filename with open ( upload , \"wb+\" ) as fo : fo . write ( f . file . read ()) b = Badfile () bf = b . is_badfile ( upload ) pathlib . Path . unlink ( upload ) # in real life you will not want to delete the file at this point if bf . classification == \"safe\" : # handle safe files here return JSONResponse ( status_code = 200 , content = { \"message\" : f \"File accepted: { bf . message } \" }) # handle unsafe files here return JSONResponse ( status_code = 403 , content = { \"message\" : f \"File rejected: { bf . message } \" }) Django \u00b6 //TODO AWS Lambda Function \u00b6 //TODO","title":"usage"},{"location":"usage/#quickstart","text":"The Badfile class provides one public method called is_badfile which analyzes a file according to the detection methods outlined here . There is also a convenance method called isolate_or_clear to handle the file in question. Their usage is demonstrated below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from badfiles.badfiles import Badfiles , isolate_or_clear b = Badfile () bad = b . is_badfile ( f = file ) \"\"\" returns a named tuple with a classification: (safe, unsafe, unknown, or not implemented) message: A message explaining the classification file: The name of the file being analyzed \"\"\" isolate_or_clear ( f = file , msg = bad , iso_dir = iso_dir , safe_dir = safe_dir , safe = [ \"safe\" ,]) \"\"\" The safe parameter is a list of badfile classifications, returned from is_badfile(), that are deemed safe (defaults to [\"safe\",]). If the classification in the msg parameter is in the safe list the file is moved to safe_dir otherwise it is moved to iso_dir. \"\"\"","title":"Quickstart"},{"location":"usage/#custom-yara-rules","text":"One may provide custom Yara detection rules upon class instantiation like so: 1 2 3 4 5 from badfiles.badfiles import Badfiles , isolate_or_clear b = Badfile ( zip_rules = \"/path/to/rules\" , tar_rules = \"/path/to/rules\" , csv_rules = \"/path/to/rules\" ) bad = b . is_badfile ( f = file )","title":"Custom Yara Rules"},{"location":"usage/#project-integration","text":"The aim of this library is to use it in larger projects and especially web applications. Here are a few ideas for how you can integrate badfiles into your current projects.","title":"Project Integration"},{"location":"usage/#fast-api","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import pathlib from fastapi import FastAPI , File , UploadFile from fastapi.responses import JSONResponse from badfiles.badfiles import Badfile import pathlib app = FastAPI () @app . get ( \"/\" ) async def root (): return { \"message\" : \"Welcome to the badfiles demo\" } @app . post ( \"/\" ) async def post_file ( f : UploadFile = File ( ... )): upload = pathlib . Path ( __file__ ) . parent / \"uploads\" / f . filename with open ( upload , \"wb+\" ) as fo : fo . write ( f . file . read ()) b = Badfile () bf = b . is_badfile ( upload ) pathlib . Path . unlink ( upload ) # in real life you will not want to delete the file at this point if bf . classification == \"safe\" : # handle safe files here return JSONResponse ( status_code = 200 , content = { \"message\" : f \"File accepted: { bf . message } \" }) # handle unsafe files here return JSONResponse ( status_code = 403 , content = { \"message\" : f \"File rejected: { bf . message } \" })","title":"Fast API"},{"location":"usage/#django","text":"//TODO","title":"Django"},{"location":"usage/#aws-lambda-function","text":"//TODO","title":"AWS Lambda Function"}]}